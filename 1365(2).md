这是一个非常高阶且巧妙的算法，叫做**“计数排序 (Counting Sort) + 前缀和 (Prefix Sum)”**思路。

它和之前的方法完全不同，它不比较数字的大小，而是 **统计数字出现的频率** 。

这种解法之所以能成立，是因为题目里有一个隐藏得很深的条件（在LeetCode原题的提示里）：

> **`0 <= nums[i] <= 100`**

也就是数组里的数字都很小，最大也就到 100。如果数字有一亿那么大，这个方法就废了。

我来把这个代码拆解成三个逻辑阶段，帮你把弯转过来：

### 阶段一：建立“频率桶” (并且做了一个小偏移)

代码：

**Python**

```
count = [0] * 102
for num in nums:
    count[num + 1] += 1
```

**为什么是 `count[num + 1]` 而不是 `count[num]`？（这是最难理解的点）**

我们要算的是“比当前数字小的个数”。

想象一下，数字 2 出现了，它对谁有贡献？

* 它不会让比 `2` 小的数变多。
* 它会让比 `2` **大**的数（比如 3, 4, 5...）发现：“哎，有一个比我小的数（也就是2）存在！”

所以，我们把数字 num 的出现次数，记录在 num + 1 的位置上。

意思是：“我是 num，我把我的存在感，存给比我大 1 的那个位置，作为它统计‘比它小’的基础。”

* 如果你是 `1`，你在 `count[2]` 加一分。
* 如果你是 `2`，你在 `count[3]` 加一分。

### 阶段二：滚雪球 (前缀和)

代码：

**Python**

```
for i in range(1, 102):
    count[i] += count[i - 1]
```

这步叫做前缀和。现在的 count 数组里，count[i] 存的是“数字 i-1 出现的次数”。

执行这一步后，count[i] 的含义变了，它变成了：

“所有小于等于 i-1 的数字出现的总次数”。

换句话说，也就是 “所有严格小于 i 的数字的总次数”。

让我们模拟一个简单的例子 `nums = [1, 2, 2, 3]`：

1. **初始填桶 (偏移存频次)：**
   * 数字 1 出现 1 次 **$\rightarrow$** `count[2] = 1`
   * 数字 2 出现 2 次 **$\rightarrow$** `count[3] = 2`
   * 数字 3 出现 1 次 **$\rightarrow$** `count[4] = 1`
   * 此时 `count` 数组（简化版）：`[0, 0, 1, 2, 1, 0...]` (下标分别对应0,1,2,3,4,5...)
2. **滚雪球 (累加)：**
   * `i=1`: `count[1]` (0) += `count[0]` (0) **$\rightarrow$** 0
   * `i=2`: `count[2]` (1) += `count[1]` (0) **$\rightarrow$** **1** (含义：小于2的数有1个)
   * `i=3`: `count[3]` (2) += `count[2]` (1) **$\rightarrow$** **3** (含义：小于3的数有 1+2=3个)
   * `i=4`: `count[4]` (1) += `count[3]` (3) **$\rightarrow$** **4** (含义：小于4的数有 3+1=4个)

### 阶段三：直接查表

代码：

**Python**

```
return [count[num] for num in nums]
```

因为我们在第二步已经算好了含义：count[i] 就是“严格小于 i 的数的个数”。

所以对于原数组里的每个 num，直接去 count 里拿 count[num] 就是答案！

* 原数字 1：查 `count[1]` **$\rightarrow$** 0
* 原数字 2：查 `count[2]` **$\rightarrow$** 1
* 原数字 3：查 `count[3]` **$\rightarrow$** 3

### 总结

这个解法的思维链条是：

1. **观察限制：** 发现数字范围很小 (0-100)。
2. **放弃比较：** 不去一个个比大小（那是 **$O(N^2)$**），也不排序（那是 **$O(N \log N)$**）。
3. **空间换时间：** 开一个 100 大小的数组。
4. **巧妙移位：** 把“数字 `k` 的频率”存在下标 `k+1` 的位置。
5. **累加统计：** 这样下标 `k` 位置累加后的值，天然就是“小于 `k` 的所有频率之和”。

这种方法叫**桶排序/计数排序**思想，速度极快（**$O(N)$**），但只适用于数字范围很小的场景。
