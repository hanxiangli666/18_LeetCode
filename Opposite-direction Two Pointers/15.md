这道第 15 题（三数之和）是算法面试中**最经典、出现频率最高**的题目之一。

它的核心思维其实是你刚才那道  **167题（两数之和 II - 有序数组）的“升级版”** 。

我们可以把它拆解成三个逻辑步骤来理解：

### 第一步：降维打击 (把 3Sum 变成 2Sum)

直接找三个数 $a + b + c = 0$ 很难。

但是，如果我们先固定其中一个数 $a$（假设它就是 nums[i]），那么问题就变成了：

> 在剩下的数组里，能不能找到两个数 **$b$** 和 **$c$**，让它们加起来等于 **$-a$**？

这就瞬间变回了你刚才做过的 **“两数之和”** 问题！

* 公式：**$b + c = -nums[i]$**
* 这就是代码中外层 `for i in range(n - 2):` 的意义：轮流让每个人当一次“固定的那个数”。

### 第二步：为什么要排序？ (解题的关键)

代码第一行 `nums.sort()` 是整个解法的灵魂。为什么要排序？有两个原因：

1. 为了使用双指针（Two Pointers）：
   你刚才在 167 题里学到了，只有在有序的情况下，才能用“一左一右往中间夹”的方法快速找到答案。既然内层循环要用双指针，那外层必须先排好序。
2. 为了去重（难点）：
   这道题最恶心的地方在于“答案中不可以包含重复的三元组”。
   * 如果不排序，`[-1, 0, 1]` 和 `[0, 1, -1]` 很难被识别为同一个答案。
   * 如果排好序了，它们都会变成 `[-1, 0, 1]`。相同的数字也会挨在一起，方便我们跳过。

### 第三步：双指针“扫荡” (代码逻辑还原)

看看你截图里的代码，完全符合这个逻辑：

1. **固定 `i`：** 选定第一个数 `nums[i]`。
2. **设立左右哨兵：**
   * `j = i + 1` (左指针，指向剩下的最小的)
   * `k = n - 1` (右指针，指向剩下的最大的)
3. **开始夹逼（就是 167 题的逻辑）：**
   * 算和：`s = x + nums[j] + nums[k]`
   * 如果 `s > 0`：太大 **$\rightarrow$** `k` 往左移。
   * 如果 `s < 0`：太小 **$\rightarrow$** `j` 往右移。
   * 如果 `s == 0`：**找到了！** 记录下来。

### 第四步：最关键的细节 —— “跳过重复”

这道题如果只是为了找出来，很简单；难就难在如何不输出重复的答案。

代码里有三处专门处理这个逻辑：

1. **外层去重：**
   * `if i > 0 and x == nums[i-1]: continue`
   * **意思：** 如果我也叫“张三”，刚才前面那个“张三”已经把活儿干完了，我就不用再干了，否则结果肯定重复。
2. **内层去重（左边）：**
   * `while j < k and nums[j] == nums[j-1]: j += 1`
   * **意思：** 找到答案后，左指针往右走，如果发现新的人和刚才的人长得一样，继续走，直到看到新面孔。
3. **内层去重（右边）：**
   * `while j < k and nums[k] == nums[k+1]: k -= 1`
   * **意思：** 同理，右指针往左走，跳过长得一样的。

---

### 总结一下这种思维

**“排序 + 双指针”** 是解决数组中“多教之和”问题（2Sum, 3Sum, 4Sum...）的标准套路。

* **看到“三数之和” **$\rightarrow$** 想到先固定一个，把问题降级为“两数之和”。**
* **看到“不重复” **$\rightarrow$** 想到必须“排序”，方便跳过相同的邻居。**

这道题的代码其实就是： **外层一个循环（固定老大） + 内层一套双指针（找老二和老三）** 。
