这张图里的代码使用的是**“哈希集合 (HashSet) 查找法”**。

这是一种非常直观、用来解决“缺失元素”类问题的思维方式。我们可以把它比作**“拿着名单点名”**。

### 这种方法是怎么想到的？

思维过程通常是这样的：

#### 第一步：确定“全集” (也就是“应该有哪些人”)

题目说数字范围是 $[1, n]$，数组长度也是 $n$。

这意味着，如果所有数字都齐了，那我们就应该看到 $1, 2, 3, ..., n$ 这些数字各出现一次。

这就是我们的**“标准名单”**。

#### 第二步：对比“现状” (也就是“实际来了哪些人”)

数组 nums 是我们要检查的对象。

最直接的想法就是：我从标准名单里，从 1 数到 $n$，挨个问：“1在吗？”，“2在吗？”……如果谁不在，把它记下来，就是“消失的数字”。

#### 第三步：解决效率瓶颈 (为什么要用 `set`？)

如果直接写代码：

**Python**

```
# 暴力解法
for i in range(1, len(nums) + 1):
    if i not in nums:  # 这一步很慢！
        ret.append(i)
```

这就遇到了一个陷阱：

* 在列表（List）里查找一个数是否存在，需要从头翻到尾，时间复杂度是 **$O(N)$**。
* 外面还有一层循环 **$1$** 到 **$n$**。
* 总耗时就是 **$O(N^2)$**。如果有 10万个数字，这个程序会跑很久（甚至超时）。

“顿悟”时刻：

怎么能让查找变得更快？

哈希表 (Set/Dict)！

在 Python 中，把列表转成集合 set(nums)，再去查 if i in set_nums，时间复杂度瞬间变成 $O(1)$（也就是不需要翻遍全书，直接跳到那一页）。

于是就有了图中的代码逻辑：

1. **造索引：** 先把手里的牌 `nums` 扔进 `set` 去重并建立索引。
2. **查户口：** 遍历 **$1$** 到 **$n$** (即 `range(1, len(nums)+1)` )。
3. **记录缺席者：** 如果 `i` 不在 `set` 里，说明它消失了。

---

### 这段代码的优缺点

* **优点：** 逻辑非常简单易懂，代码短，时间复杂度是优秀的 **$O(N)$**。
* 缺点（注意看题目下方的进阶提示）：
  题目下方有一行小字：“进阶：你能在不使用额外空间...解决这个问题吗？”
  这段代码使用了 set_nums = set(nums)，这开辟了额外的内存空间来存储集合，空间复杂度是 $O(N)$。

如果是面试：

这段代码通常是第一阶段的回答。面试官可能会接着问：“既然题目说数字都在 $1-n$ 之间，能不能利用数组本身的下标来做标记，从而不使用 set 省掉那 $O(N)$ 的空间？”（那是另一种叫“原地哈希/负数标记法”的技巧）。

但作为初学或者快速解题，图中这个方法是非常标准的满分逻辑。
