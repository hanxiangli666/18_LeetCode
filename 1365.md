这是一种非常经典且实用的算法思维，叫做“排序 + 哈希表映射”。

要想通这种方法，其实只需要经历三个逻辑上的“顿悟”步骤。我来带你还原一下这个思维过程：

### 第一步：从“比我小”联想到“排队” (直觉)

最笨的方法是拿每一个数去和别的数比较（双重循环，$O(N^2)$）。

但是，你可以换个角度想：如果大家已经按身高（数值）排好队了，我知道我站在第几个位置，不就知道有多少人比我矮了吗？

* 比如：`[1, 2, 3, 8]`
* 数字 `3` 在下标 `2` 的位置（从0开始数），说明前面正好有 `2` 个数比它小。

**结论 1：** 只要把数组 **排序** ，数字所在的 **下标索引 (Index)** ，天然就是“比它小的数的个数”。

### 第二步：处理“并列名次” (核心难点)

普通的排序有一个问题：如果有重复的数字怎么办？

比如截图中的例子：[1, 2, 2, 3, 8]

* 第一个 `2` 在下标 `1`。
* 第二个 `2` 在下标 `2`。

如果直接用下标，第二个 `2` 会以为有 2 个数比它小，但实际上比它小的只有 `1` (共1个)。

**思维突破：** 在排序后的数组中，如果遇到相同的数字， **只有第一个出现的那个数字的下标是准确的** 。后面的重复数字应该和第一个一样。

**结论 2：** 我们遍历排序后的数组，记录下标时， **如果是第一次遇到的数字，就记录下来；如果见过了，就跳过** 。这就是代码中 `if num not in d` 的由来。

### 第三步：如何回到原来的顺序？ (哈希表的作用)

我们刚才为了找名次，把数组打乱（排序）了。但是题目要求按照**原始数组**的顺序输出答案。

* 原始数组：`[8, 1, 2, 2, 3]`
* 我们手里现在的资讯：知道 `8` 对应 4，`1` 对应 0，`2` 对应 1...

这时候就需要一个“记账本”（哈希表/字典）。

我们将排序算出来的结果存进字典 d：

* `d = {1: 0, 2: 1, 3: 3, 8: 4}`
* 含义是：`{数字: 比它小的个数}`

最后，再回过头遍历 **原始数组** ，拿着数字去字典里查，填入结果列表。

---

### 总结一下这个思维链条：

1. **找规律：** 想知道多少人比我小 **$\rightarrow$** 排好队看下标最快。 **$\rightarrow$**  **决定排序** 。
2. **填坑：** 排队发现有重复数字 **$\rightarrow$** 只认第一次出现的下标。 **$\rightarrow$**  **逻辑优化** 。
3. **还原：** 排完序顺序乱了，怎么对应回原数组？ **$\rightarrow$** 用字典记录 `{数值: 答案}` **$\rightarrow$**  **引入哈希表** 。

### 代码对应解析

看看你截图里的代码，正好对应这三步：

1. `temp = sorted((nums))`
   * **对应思维：** 先排序，创造上帝视角。
2. `for i, num in enumerate(temp): if num not in d: d[num] = i`
   * **对应思维：** 利用下标 `i` 作为答案。`if num not in d` 是为了保证如果有重复数字（比如两个2），只记录第一个2的下标（因为那才是比它严格小的数量）。
3. `for i in nums: ret.append(d[i])`
   * **对应思维：** 回到原始数组，查表（字典）填空，输出答案。

这种方法将时间复杂度从暴力解法的 **$O(N^2)$** 降低到了 **$O(N \log N)$**（因为主要是排序耗时），是非常标准的优化手段。
